<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Обучение | UZTELECOM</title>
    
    <!-- Временно используем старые стили для совместимости -->
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="css/window-manager.css">
    <link rel="stylesheet" href="css/sidebar-pin.css">
    <link rel="stylesheet" href="css/appeals.css">
    <link rel="stylesheet" href="css/file-attachment.css">
    <link rel="stylesheet" href="css/comment-file-attachment.css">
    <link rel="stylesheet" href="css/appeal-modal.css">
    <link rel="stylesheet" href="css/slider-tooltip.css">
    <link rel="stylesheet" href="css/analytics-dashboard.css">
    
    <!-- Подключение Google Fonts -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="assets/синее лого.png">
</head>
<body>        <header class="header-fixed">
            <div class="header-title">
                Обучение
            </div>
            <!-- Кнопки редактирования (скрыты по умолчанию) -->
            <div class="header-editor-controls" id="header-editor-controls" style="display: none;">
                <button class="editor-btn save-btn" id="save-btn">
                    <span class="material-icons">save</span>
                    Сохранить
                </button>
                <button class="editor-btn cancel-btn" id="cancel-btn">
                    <span class="material-icons">close</span>
                    Отменить
                </button>
                <button class="editor-btn add-remove-btn" id="add-remove-btn">
                    <span class="material-icons">add_box</span>
                    Добавить/Убрать
                </button>
                <button class="editor-btn reset-btn" id="reset-windows-btn">
                    <span class="material-icons">refresh</span>
                    Сбросить настройки окон
                </button>
                <!-- Выпадающий список для добавления окон -->
                <div class="window-selector-dropdown" id="window-selector-dropdown">
                    <div class="window-selector-header">
                        <span class="material-icons">widgets</span>
                        <span>Доступные окна</span>
                    </div>
                    <div class="window-selector-list">
                        <label class="window-selector-item">
                            <input type="checkbox" data-window="operators-list" checked>
                            <span class="checkmark"></span>
                            <span class="window-name">Выявленные ошибки операторов</span>
                        </label>
                        <label class="window-selector-item">
                            <input type="checkbox" data-window="operator-details">
                            <span class="checkmark"></span>
                            <span class="window-name">Подробная информация ошибок</span>
                        </label>
                        <label class="window-selector-item">
                            <input type="checkbox" data-window="analytics-dashboard">
                            <span class="checkmark"></span>
                            <span class="window-name">Аналитика учебного процесса</span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="header-group">
                <div class="header-group-select">
                    <span class="header-group-selected">Группа 1000</span>
                    <span class="material-icons header-group-arrow">arrow_drop_down</span>
                    <ul class="header-group-list">
                        <li data-value="Группа 1000" class="active">Группа 1000</li>
                        <li data-value="Группа 1242">Группа 1242</li>
                        <li data-value="Группа 1093">Группа 1093</li>
                        <li data-value="Группа 1170">Группа 1170</li>
                        <li data-value="Группа ДОП">Группа ДОП</li>
                    </ul>
                </div>
                <div class="header-user" id="header-user">
                    <img src="assets/Аватар/Foto.jpg" alt="user" class="header-user-img">
                    <span>Рискиев Б.</span>
                    <div class="header-dropdown" id="header-dropdown">
                        <a href="#" id="editor-toggle"><span class="material-icons">edit</span> Редактор</a>
                        <a href="#"><span class="material-icons">language</span> Изменить язык</a>
                    </div>
                </div>
            </div>
        </header>
        <div class="main-layout">
            <!-- Sidebar -->
            <aside class="sidebar sidebar-figma collapsible-sidebar" onmouseenter="this.classList.add('open')" onmouseleave="this.classList.remove('open')">
                <div class="sidebar-logo">
                    <img src="assets/mini.png" alt="UZTELECOM Logo" class="sidebar-logo-img" id="sidebar-logo-img">
                    <div class="sidebar-logo-text">
                        <div class="sidebar-logo-title"></div>
                        <div class="sidebar-logo-sub"></div>
                    </div>
                </div>
                <nav class="sidebar-menu-figma">
                    <a class="active"><span class="material-icons">school</span> <span class="sidebar-label">Обучение</span></a>
                    <a href="http://192.168.42.172:5001/" target="_blank"><span class="material-icons">checklist</span> <span class="sidebar-label">Лист контроль</span></a>
                    <a><span class="material-icons">notifications</span> <span class="sidebar-label">Уведомления</span> <span class="sidebar-badge">1</span></a>
                    <a><span class="material-icons">groups</span> <span class="sidebar-label">Операторы</span></a>
                    <a><span class="material-icons">assignment</span> <span class="sidebar-label">Отработки</span></a>
                    <a><span class="material-icons">report_problem</span> <span class="sidebar-label">Технический сбой</span></a>
                    <a><span class="material-icons">person_add</span> <span class="sidebar-label">Привлечение к работам</span></a>
                    <a><span class="material-icons">bar_chart</span> <span class="sidebar-label">Статистика супервайзера</span></a>
                    <a><span class="material-icons">settings</span> <span class="sidebar-label">Настройки</span></a>
                </nav>
                
                <!-- Кнопки фиксации сайдбара - размещены в самом низу -->
                <div class="sidebar-pin-controls">
                    <button class="pin-button pin-button-collapsed" id="sidebar-pin-collapsed-btn" title="Зафиксировать в закрытом виде">
                        <span class="material-icons">push_pin</span>
                        <span class="sidebar-label">Закрепить закрытым</span>
                    </button>
                    <button class="pin-button pin-button-expanded" id="sidebar-pin-expanded-btn" title="Зафиксировать в открытом виде">
                        <span class="material-icons">lock</span>
                        <span class="sidebar-label">Закрепить открытым</span>
                    </button>
                </div>
                
                <a class="sidebar-exit" href="login.html"><span class="material-icons">logout</span> <span class="sidebar-label">Выйти</span></a>
            </aside>
            <!-- Main Content -->
            <main class="main-content training-page">
                <div class="training-layout">
                    <!-- Окно "Выявленные ошибки операторов" -->
                    <div class="training-window operators-errors-window" id="operators-errors-window">
                        <div class="window-header">
                            <div class="window-title-section">
                                <span class="material-icons">person_search</span>
                                <span>Выявленные ошибки операторов</span>
                            </div>
                            <div class="window-controls">
                                <button class="window-control-btn minimize-btn" title="Свернуть">
                                    <span class="material-icons">remove</span>
                                </button>
                                <button class="window-control-btn maximize-btn" title="Развернуть">
                                    <span class="material-icons">crop_din</span>
                                </button>
                                <button class="window-control-btn close-btn" title="Закрыть" style="display: none;">
                                    <span class="material-icons">close</span>
                                </button>
                            </div>
                        </div>
                        <div class="window-content">
                            <!-- Поиск и фильтры -->
                            <div class="operators-search-section">
                                <div class="search-input-container">
                                    <span class="material-icons search-icon">search</span>
                                    <input type="text" 
                                           class="operators-search-input" 
                                           id="operators-search-input"
                                           placeholder="Поиск оператора">
                                    <button class="refresh-operators-btn" 
                                            id="refresh-operators-btn" 
                                            title="Обновить список операторов">
                                        <span class="material-icons">refresh</span>
                                    </button>
                                </div>
                                <div class="operators-filters">
                                    <label class="filter-toggle">
                                        <input type="radio" name="operator-filter" value="all" checked>
                                        <span class="filter-text">Все</span>
                                    </label>
                                    <label class="filter-toggle filter-toggle-blue">
                                        <input type="radio" name="operator-filter" value="untrained">
                                        <span class="filter-text">Необученные</span>
                                    </label>
                                    <label class="filter-toggle">
                                        <input type="radio" name="operator-filter" value="training-date">
                                        <span class="filter-text">Дата обучения</span>
                                    </label>
                                </div>
                            </div>
                            
                            <!-- Список операторов -->
                            <div class="operators-list-container">
                                <!-- Операторы будут добавляться динамически -->
                            </div>
                        </div>
                        <div class="resize-handle"></div>
                    </div>
                    
                    <!-- Окно "Подробная информация ошибок" -->
                    <div class="training-window operator-details-window" id="operator-details-window" style="display: none; top: 20px; left: 450px; width: 800px; height: 600px;">
                        <div class="window-header">
                            <div class="window-title-section">
                                <span class="material-icons">assignment</span>
                                <span>Подробная информация ошибок</span>
                                <span class="operator-name-indicator" id="operator-name-indicator">- Выберите оператора</span>
                            </div>
                            <div class="window-controls">
                                <button class="window-control-btn minimize-btn" title="Свернуть">
                                    <span class="material-icons">remove</span>
                                </button>
                                <button class="window-control-btn maximize-btn" title="Развернуть">
                                    <span class="material-icons">crop_din</span>
                                </button>
                                <button class="window-control-btn close-btn" title="Закрыть" style="display: none;">
                                    <span class="material-icons">close</span>
                                </button>
                            </div>
                        </div>
                        <div class="window-content">
                            <!-- Информация о выбранном операторе -->
                            <div class="selected-operator-info" id="selected-operator-info" style="display: none;">
                                <div class="operator-header">
                                    <img src="" alt="Аватар оператора" class="operator-detail-avatar" id="operator-detail-avatar">
                                    <div class="operator-detail-info">
                                        <div class="operator-detail-name" id="operator-detail-name"></div>
                                        <div class="operator-detail-stats">
                                            <div class="stat-item">
                                                <span class="material-icons">error</span>
                                                <span class="stat-number" id="operator-detail-errors">0</span>
                                                <span class="stat-label">Необученных звонков</span>
                                            </div>
                                            <div class="stat-item">
                                                <span class="material-icons">check_circle</span>
                                                <span class="stat-number" id="operator-detail-success">0</span>
                                                <span class="stat-label">Обученных звонков</span>
                                            </div>
                                            <div class="stat-item">
                                                <span class="material-icons">analytics</span>
                                                <span class="stat-number" id="operator-detail-average">0</span>
                                                <span class="stat-label">Общее кол-во допущенных ошибок</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="operator-actions">
                                        <div class="toggle-group">
                                            <div class="switch">
                                                <input type="checkbox" id="training-date-toggle">
                                                <span class="slider"></span>
                                            </div>
                                        </div>
                                        <div class="date-group">
                                            <span class="date-value">12.06.2024 / 10:40</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Список ошибок оператора -->

                            <div class="operator-errors-list" id="operator-errors-list">
                                <!-- Здесь будут отображаться ошибки выбранного оператора -->
                            </div>
                            
                            <!-- Заглушка когда оператор не выбран -->
                            <div class="no-operator-selected" id="no-operator-selected">
                                <div class="empty-state">
                                    <span class="material-icons">person_search</span>
                                    <h3>Выберите оператора</h3>
                                    <p>Для просмотра подробной информации об ошибках выберите оператора из списка слева</p>
                                </div>
                            </div>
                        </div>
                        <div class="resize-handle"></div>
                    </div>
                    
                    <!-- Окно "Аналитика учебного процесса" -->
                    <div class="training-window analytics-dashboard-window" id="analytics-dashboard-window" style="display: none; top: 40px; left: 900px; width: 1000px; height: 700px;">
                        <div class="window-header">
                            <div class="window-title-section">
                                <span class="material-icons">analytics</span>
                                <span>Аналитика учебного процесса</span>
                            </div>
                            <div class="window-controls">
                                <button class="window-control-btn minimize-btn" title="Свернуть">
                                    <span class="material-icons">remove</span>
                                </button>
                                <button class="window-control-btn maximize-btn" title="Развернуть">
                                    <span class="material-icons">crop_din</span>
                                </button>
                                <button class="window-control-btn close-btn" title="Закрыть" style="display: none;">
                                    <span class="material-icons">close</span>
                                </button>
                            </div>
                        </div>
                        <div class="window-content">
                            
                            <!-- Основное содержимое аналитики -->
                            <div class="analytics-content">
                                <div class="analytics-compact-row" style="display: flex; align-items: flex-start; gap: 10px;">
                                    <div class="analytics-chart-container" style="min-width: 180px; max-width: 260px; background: #fff; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.04); padding: 5px 5px; display: flex; flex-direction: column; align-items: center; justify-content: flex-start;">
                                        <div class="analytics-chart-title" style="font-size: 12px; font-weight: 700; margin-bottom: 0px; text-align: center;">Статистика обучения</div>
                                        <div class="analytics-chart-flex" style="display: flex; flex-direction: row; align-items: center; justify-content: flex-start; width: 100%; gap: 0px;">
                                            <div class="analytics-chart" style="display: flex; align-items: center; justify-content: center; min-width: 120px;">
                                                <canvas id="analytics-pie-chart" width="120" height="120"></canvas>
                                            </div>
                                            <div class="analytics-chart-info-list" style="display: flex; flex-direction: column; gap: 6px; min-width: 110px;">
                                                <div class="analytics-chart-info">Обучено всего: <span id="trained-calls-archive">1000</span></div>
                                                <div class="analytics-chart-info">Обучено за день: <span id="trained-calls-count">54</span></div>
                                                <div class="analytics-chart-info">Необучено: <span id="untrained-calls-count">46</span></div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="analytics-criteria-table" style="flex: 1; min-width: 0;">
                                        <table class="criteria-table" style="width: 100%; margin: 0; border-collapse: separate; border-spacing: 0;">
                                            <thead>
                                                <tr>
                                                    <th style="width: 40px;">#</th>
                                                    <th style="text-align: left;">Критерий оценки</th>
                                                    <th style="width: 70px; text-align: right;">%</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>01</td>
                                                    <td>Приветствие</td>
                                                    <td><span class="percentage-badge" style="background: #e3f2fd; color: #1976d2; padding: 2px 10px; border-radius: 12px; font-weight: 500;">92%</span></td>
                                                </tr>
                                                <tr>
                                                    <td>02</td>
                                                    <td>Внимательное слушание</td>
                                                    <td><span class="percentage-badge" style="background: #e8f5e9; color: #388e3c; padding: 2px 10px; border-radius: 12px; font-weight: 500;">88%</span></td>
                                                </tr>
                                                <tr>
                                                    <td>03</td>
                                                    <td>Использование уточняющих вопросов</td>
                                                    <td><span class="percentage-badge" style="background: #fffde7; color: #fbc02d; padding: 2px 10px; border-radius: 12px; font-weight: 500;">75%</span></td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="resize-handle"></div>
                    </div>
                    
                    <!-- Временная заглушка для проверки функциональности -->
                    <div class="training-placeholder">
                        <h2>Режим обучения</h2>
                        <p>Нажмите "Редактор" для настройки интерфейса</p>
                        <div class="placeholder-info">
                            <p><strong>Информация:</strong></p>
                            <ul>
                                <li>Изменение размера окон и кнопки свернуть/развернуть доступны всегда</li>
                                <li>Перемещение окон доступно только в режиме редактирования</li>
                                <li>Для входа в режим редактирования нажмите "Редактор" в правом верхнем углу</li>
                                <li>В режиме редактирования окна будут выделены синей рамкой и станут доступны для перемещения</li>
                                <li>Кнопка закрытия окон появляется только в режиме редактирования</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </main>
        </div>
        <script src="script.js"></script>
        <script src="js/sidebar-pin-manager.js"></script>
        <script src="js/appeals-manager.js"></script>
        <script src="js/file-attachment-manager.js"></script>
        <script src="js/comment-file-attachment-manager.js"></script>
        <script src="js/analytics-manager.js"></script>
        <script>
document.addEventListener('DOMContentLoaded', function() {
    // Режим редактирования окон - объявляем в начале
    let editMode = false;

    // Автоинициализация аналитики при загрузке, если окно видно
    const analyticsWindow = document.getElementById('analytics-dashboard-window');
    if (analyticsWindow && analyticsWindow.style.display !== 'none' && getComputedStyle(analyticsWindow).display !== 'none') {
        try {
            if (window.AnalyticsManager) {
                setTimeout(() => {
                    window.AnalyticsManager.init();
                }, 100);
            }
        } catch (error) {
            console.error('Ошибка при автоинициализации AnalyticsManager:', error);
        }
    }
    
    // Восстановление состояния окна аналитики из localStorage
    const analyticsState = localStorage.getItem('analyticsDashboardVisible');
    if (analyticsWindow) {
        if (analyticsState === 'true') {
            analyticsWindow.style.display = 'flex';
            try {
                if (window.AnalyticsManager) {
                    setTimeout(() => {
                        window.AnalyticsManager.init();
                    }, 100);
                }
            } catch (error) {
                console.error('Ошибка при автоинициализации AnalyticsManager:', error);
            }
        } else {
            analyticsWindow.style.display = 'none';
        }
    }
    
    // Скрипт для кастомного select
    const groupSelect = document.querySelector('.header-group-select');
    const groupSelected = document.querySelector('.header-group-selected');
    const groupList = document.querySelector('.header-group-list');
    const groupItems = document.querySelectorAll('.header-group-list li');
    groupSelect.onclick = function(e) {
        groupList.classList.toggle('show');
    };
    groupItems.forEach(item => {
        item.onclick = function(e) {
            groupSelected.textContent = this.textContent;
            groupItems.forEach(i => i.classList.remove('active'));
            this.classList.add('active');
            groupList.classList.remove('show');
            e.stopPropagation();
        };
    });
    document.addEventListener('click', function(e) {
        if (!groupSelect.contains(e.target)) {
            groupList.classList.remove('show');
        }
    });
    // Меняем логотип при раскрытии/сжатии сайдбара и сдвигаем header-title
    const sidebar = document.querySelector('.sidebar');
    const logoImg = document.getElementById('sidebar-logo-img');
    if (sidebar && logoImg) {
        sidebar.addEventListener('mouseenter', () => {
            // Проверяем, не зафиксирован ли сайдбар
            if (window.isSidebarPinned && window.isSidebarPinned()) {
                return; // Не меняем логотип и не открываем сайдбар, если он зафиксирован
            }
            
            logoImg.src = 'assets/logo.png';
            sidebar.classList.add('open');
            document.body.classList.add('sidebar-open');
            // Обновляем размеры максимизированных окон
            updateMaximizedWindowsSize();
        });
        sidebar.addEventListener('mouseleave', () => {
            // Проверяем, не зафиксирован ли сайдбар
            if (window.isSidebarPinned && window.isSidebarPinned()) {
                return; // Не меняем логотип и не закрываем сайдбар, если он зафиксирован
            }
            
            logoImg.src = 'assets/mini.png';
            sidebar.classList.remove('open');
            document.body.classList.remove('sidebar-open');
            // Обновляем размеры максимизированных окон
            updateMaximizedWindowsSize();
        });
    }
    
    // Функция для обновления размеров максимизированных окон при изменении sidebar
    function updateMaximizedWindowsSize() {
        // Теперь максимизированные окна позиционируются относительно training-layout,
        // поэтому нам не нужно их перепозиционировать при изменении sidebar
        // training-layout сам изменит свои размеры благодаря CSS transitions
        console.log('Размеры training-layout автоматически обновились');
    }
    
    const headerUserImg = document.querySelector('.header-user-img');
    const headerDropdown = document.getElementById('header-dropdown');
    if (headerUserImg && headerDropdown) {
        headerUserImg.addEventListener('click', function(e) {
            headerDropdown.classList.toggle('show');
            e.stopPropagation();
        });
        document.addEventListener('click', function(e) {
            if (!headerDropdown.contains(e.target) && e.target !== headerUserImg) {
                headerDropdown.classList.remove('show');
            }
        });
    }
    
    // Режим редактирования окон
    const editorToggle = document.getElementById('editor-toggle');
    const headerEditorControls = document.getElementById('header-editor-controls');
    const saveBtn = document.getElementById('save-btn');
    const cancelBtn = document.getElementById('cancel-btn');
    const addRemoveBtn = document.getElementById('add-remove-btn');

    // Функция для входа в режим редактирования
    function enterEditMode() {
        editMode = true;
        document.body.classList.add('windows-edit-mode');
        headerEditorControls.style.display = 'flex';
        setTimeout(() => {
            headerEditorControls.classList.add('show');
        }, 10);
        
        // Показываем кнопки закрытия окон
        document.querySelectorAll('.close-btn').forEach(btn => {
            btn.style.display = 'block';
        });
        
        // Включаем кнопки развертывания
        document.querySelectorAll('.maximize-btn').forEach(btn => {
            btn.classList.remove('disabled');
            btn.style.cursor = 'pointer';
            btn.title = 'Развернуть окно';
        });
        
        // Включаем кнопки свертывания (они всегда активны)
        document.querySelectorAll('.minimize-btn').forEach(btn => {
            btn.classList.remove('disabled');
            btn.style.cursor = 'pointer';
            btn.title = 'Свернуть/развернуть окно';
        });
        
        // Закрываем dropdown
        headerDropdown.classList.remove('show');
        
        // Показываем уведомление
        showNotification('Режим редактирования активирован. Теперь можно перемещать окна.', 'info');
        
        console.log('Режим редактирования активирован');
    }

    // Функция для выхода из режима редактирования
    function exitEditMode() {
        editMode = false;
        document.body.classList.remove('windows-edit-mode');
        headerEditorControls.classList.remove('show');
        
        // Скрываем кнопки закрытия окон
        document.querySelectorAll('.close-btn').forEach(btn => {
            btn.style.display = 'none';
        });
        
        // Отключаем кнопки развертывания
        document.querySelectorAll('.maximize-btn').forEach(btn => {
            btn.classList.add('disabled');
            btn.style.cursor = 'not-allowed';
            btn.title = 'Развертывание доступно только в режиме редактирования';
        });
        
        // Кнопки свертывания остаются активными (они работают всегда)
        document.querySelectorAll('.minimize-btn').forEach(btn => {
            btn.classList.remove('disabled');
            btn.style.cursor = 'pointer';
            btn.title = 'Свернуть/развернуть окно';
        });
        
        // Скрываем dropdown окон при выходе из режима редактирования
        const windowSelectorDropdown = document.getElementById('window-selector-dropdown');
        if (windowSelectorDropdown) {
            windowSelectorDropdown.classList.remove('show');
        }
        
        setTimeout(() => {
            headerEditorControls.style.display = 'none';
        }, 300);
        
        console.log('Режим редактирования деактивирован');
    }

    // Обработчик для кнопки "Редактор"
    if (editorToggle) {
        editorToggle.addEventListener('click', function(e) {
            e.preventDefault();
            enterEditMode();
        });
    }

    // Обработчики для кнопок редактирования
    if (saveBtn) {
        saveBtn.addEventListener('click', function(e) {
            e.preventDefault();
            // Здесь будет логика сохранения
            console.log('Сохранение изменений...');
            exitEditMode();
        });
    }

    if (cancelBtn) {
        cancelBtn.addEventListener('click', function(e) {
            e.preventDefault();
            // Здесь будет логика отмены изменений
            console.log('Отмена изменений...');
            exitEditMode();
        });
    }

    if (addRemoveBtn) {
        addRemoveBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const dropdown = document.getElementById('window-selector-dropdown');
            dropdown.classList.toggle('show');
            
            console.log('Открытие/закрытие списка окон...');
        });
    }

    // Обработка выпадающего списка окон
    const windowSelectorDropdown = document.getElementById('window-selector-dropdown');
    
    // Закрытие dropdown при клике вне его
    document.addEventListener('click', function(e) {
        if (windowSelectorDropdown && !windowSelectorDropdown.contains(e.target) && e.target !== addRemoveBtn) {
            windowSelectorDropdown.classList.remove('show');
        }
    });
    
    // Обработка чекбоксов
    const windowCheckboxes = document.querySelectorAll('.window-selector-item input[type="checkbox"]');
    windowCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', function(e) {
            const windowType = this.getAttribute('data-window');
            const isChecked = this.checked;
            
            console.log(`Окно "${windowType}" ${isChecked ? 'включено' : 'выключено'}`);
            
            // Здесь будет логика добавления/удаления окон
            if (isChecked) {
                addWindow(windowType);
            } else {
                removeWindow(windowType);
            }
        });
    });
    
    // Функция для проверки видимых окон и управления заглушкой
    function checkPlaceholderVisibility() {
        const placeholder = document.querySelector('.training-placeholder');
        
        if (!placeholder) return;
        
        // Проверяем конкретные окна
        const operatorsWindow = document.getElementById('operators-errors-window');
        const detailsWindow = document.getElementById('operator-details-window');
        const analyticsWindow = document.getElementById('analytics-dashboard-window');
        
        const operatorsVisible = operatorsWindow && 
            operatorsWindow.style.display !== 'none' && 
            getComputedStyle(operatorsWindow).display !== 'none';
            
        const detailsVisible = detailsWindow && 
            detailsWindow.style.display !== 'none' && 
            getComputedStyle(detailsWindow).display !== 'none';
            
        const analyticsVisible = analyticsWindow && 
            analyticsWindow.style.display !== 'none' && 
            getComputedStyle(analyticsWindow).display !== 'none';
        
        // Скрываем или показываем заглушку
        if (operatorsVisible || detailsVisible || analyticsVisible) {
            placeholder.style.display = 'none';
        } else {
            placeholder.style.display = 'block';
        }
    }

    // Функция добавления окна
    function addWindow(windowType) {
        console.log(`Добавляем окно: ${windowType}`);
        
        if (windowType === 'operators-list') {
            const operatorsWindow = document.getElementById('operators-errors-window');
            if (operatorsWindow) {
                operatorsWindow.style.display = 'flex';
                initOperatorsList();
                // Сохраняем состояние окна
                WindowStateManager.saveWindowState(operatorsWindow);
            }
        } else if (windowType === 'operator-details') {
            const detailsWindow = document.getElementById('operator-details-window');
            if (detailsWindow) {
                detailsWindow.style.display = 'flex';
                // Сохраняем состояние окна
                WindowStateManager.saveWindowState(detailsWindow);
            }
        } else if (windowType === 'analytics-dashboard') {
            const analyticsWindow = document.getElementById('analytics-dashboard-window');
            if (analyticsWindow) {
                analyticsWindow.style.display = 'flex';
                // Сохраняем состояние окна в localStorage
                localStorage.setItem('analyticsDashboardVisible', 'true');
                // Инициализируем аналитику с защитой от ошибок
                try {
                    if (window.AnalyticsManager) {
                        setTimeout(() => {
                            window.AnalyticsManager.init();
                        }, 100);
                    }
                } catch (error) {
                    console.error('Ошибка при инициализации AnalyticsManager:', error);
                }
                // Сохраняем состояние окна
                WindowStateManager.saveWindowState(analyticsWindow);
            }
        }
        
        // Проверяем нужно ли скрыть заглушку
        checkPlaceholderVisibility();
    }
    
    // Функция удаления окна
    function removeWindow(windowType) {
        console.log(`Удаляем окно: ${windowType}`);
        
        if (windowType === 'operators-list') {
            const operatorsWindow = document.getElementById('operators-errors-window');
            if (operatorsWindow) {
                operatorsWindow.style.display = 'none';
                // Сохраняем состояние окна
                WindowStateManager.saveWindowState(operatorsWindow);
            }
        } else if (windowType === 'operator-details') {
            const detailsWindow = document.getElementById('operator-details-window');
            if (detailsWindow) {
                detailsWindow.style.display = 'none';
                // Сохраняем состояние окна
                WindowStateManager.saveWindowState(detailsWindow);
            }
        } else if (windowType === 'analytics-dashboard') {
            const analyticsWindow = document.getElementById('analytics-dashboard-window');
            if (analyticsWindow) {
                analyticsWindow.style.display = 'none';
                // Сохраняем состояние окна в localStorage
                localStorage.setItem('analyticsDashboardVisible', 'false');
                // Уничтожаем ресурсы аналитики с защитой от ошибок
                try {
                    if (window.AnalyticsManager) {
                        window.AnalyticsManager.destroy();
                    }
                } catch (error) {
                    console.error('Ошибка при уничтожении AnalyticsManager:', error);
                }
                // Сохраняем состояние окна
                WindowStateManager.saveWindowState(analyticsWindow);
            }
        }
        
        // Сохраняем состояние всех окон
        WindowStateManager.saveAllWindowStates();
        
        // Проверяем нужно ли показать заглушку
        checkPlaceholderVisibility();
    }
    
    // Инициализация списка операторов
    function initOperatorsList() {
        // Список доступных аватаров
        const avatars = [
            "1P8A0085.jpg",
            "1P8A0111.jpg", 
            "1P8A0141.jpg",
            "1P8A0193.jpg",
            "1P8A0199.jpg",
            "1P8A0276.jpg",
            "1P8A0543.jpg",
            "2Y0A0426.jpg",
            "2Y0A9000.png",
            "2Y0A9032.png",
            "2Y0A9049.png",
            "2Y0A9086.png",
            "2Y0A9323.png",
            "2Y0A9346.png",
            "2Y0A9419.png",
            "2Y0A9427.png",
            "2Y0A9433.png",
            "2Y0A9689.jpg",
            "Adilova Arofat Faxriddin qizi.jpg",
            "Foto.jpg",
            "Fozilxonov Zoirxon Davron o'g'ли 0147.png",
            "Пулатова Юлдуз.png"
        ];
        
        // Список случайных имен для операторов
        const names = [
            "Алиев Шерзод Бахтиярович",
            "Каримова Нилуфар Азимовна", 
            "Рахимов Жасур Олимович",
            "Умарова Дилдора Рустамовна",
            "Носиров Азиз Фарходович",
            "Исакова Мадина Шухратовна",
            "Холиков Бахтиёр Мухаммадович",
            "Турсунова Нигора Анваровна",
            "Абдуллаев Отабек Камилович",
            "Нурматова Севара Улугбековна",
            "Мирзаев Фаррух Собирович",
            "Жуманиязова Гульшан Рахматовна",
            "Хашимов Санжар Тохирович",
            "Файзуллаева Малика Нуриддиновна",
            "Самадов Жавлон Икромович",
            "Кодирова Шахноза Абдувахобовна",
            "Эргашев Достон Мухтарович",
            "Ибрагимова Дилноза Шавкатовна",
            "Султанов Джахонгир Бахромович",
            "Хамидова Наргиза Элмуродовна",
            "Расулов Акмал Садиkович",
            "Юсупова Нодира Хакимовна"
        ];
        
        // Временные интервалы
        const timeOptions = [
            "15 мин. назад", "30 мин. назад", "45 мин. назад",
            "1 час назад", "1.5 часа назад", "2 часа назад", 
            "2.5 часа назад", "3 часа назад", "4 часа назад", "5 часов назад"
        ];
        
        // Генерируем случайные данные операторов
        function generateRandomOperators() {
            const operators = [];
            const usedAvatars = [];
            const usedNames = [];
            
            // Создаем 15-20 операторов
            const operatorCount = Math.floor(Math.random() * 6) + 15; // 15-20 операторов
            
            for (let i = 0; i < operatorCount; i++) {
                // Выбираем случайный аватар (без повторов если возможно)
                let avatar;
                if (usedAvatars.length < avatars.length) {
                    do {
                        avatar = avatars[Math.floor(Math.random() * avatars.length)];
                    } while (usedAvatars.includes(avatar));
                    usedAvatars.push(avatar);
                } else {
                    avatar = avatars[Math.floor(Math.random() * avatars.length)];
                }
                
                // Выбираем случайное имя (без повторов если возможно)
                let name;
                if (usedNames.length < names.length) {
                    do {
                        name = names[Math.floor(Math.random() * names.length)];
                    } while (usedNames.includes(name));
                    usedNames.push(name);
                } else {
                    name = names[Math.floor(Math.random() * names.length)];
                }
                
                // Генерируем случайный номер сотрудника
                const employeeNumber = String(Math.floor(Math.random() * 9000) + 1000);
                
                // Генерируем случайные показатели
                const errors = Math.floor(Math.random() * 20); // Необученные ошибки
                const success = Math.floor(Math.random() * 50) + 10; // Успешные обращения
                const trainedErrors = Math.floor(Math.random() * 10); // Обученные ошибки
                const totalErrors = errors + trainedErrors; // Общее количество ошибок (необученные + обученные)
                
                // Определяем статус на основе количества ошибок
                const status = errors > 10 ? "error" : "success";
                
                // Генерируем дату последнего обучения для обученных операторов
                let lastTrainingDate = null;
                if (errors <= 10 && Math.random() < 0.7) { // 70% обученных операторов имеют дату обучения
                    const daysAgo = Math.floor(Math.random() * 30) + 1; // от 1 до 30 дней назад
                    lastTrainingDate = new Date(Date.now() - daysAgo * 24 * 60 * 60 * 1000);
                }
                
                operators.push({
                    id: i + 1,
                    name: `${name} (${employeeNumber})`,
                    avatar: `assets/Аватар/${avatar}`,
                    errors: errors, // Необученные ошибки
                    success: success, // Успешные обращения
                    calendar: totalErrors, // Общее количество ошибок (используется поле calendar для обратной совместимости)
                    time: timeOptions[Math.floor(Math.random() * timeOptions.length)],
                    status: status,
                    lastTrainingDate: lastTrainingDate
                });
            }
            
            return operators;
        }
        
        const operatorsData = generateRandomOperators();
        
        // Сохраняем данные глобально для обновления
        window.currentOperatorsData = operatorsData;
        
        // Применяем сортировку по умолчанию (все операторы, по убыванию ошибок)
        const sortedOperators = applyOperatorFilter(operatorsData, 'all');
        
        renderOperatorsList(sortedOperators);
        setupOperatorsSearch(operatorsData);
        setupOperatorsFilters(operatorsData);
        setupRefreshButton();
    }
    
    // Функция для обновления списка операторов
    function refreshOperatorsList() {
        const avatars = [
            "1P8A0085.jpg", "1P8A0111.jpg", "1P8A0141.jpg", "1P8A0193.jpg", "1P8A0199.jpg",
            "1P8A0276.jpg", "1P8A0543.jpg", "2Y0A0426.jpg", "2Y0A9000.png", "2Y0A9032.png",
            "2Y0A9049.png", "2Y0A9086.png", "2Y0A9323.png", "2Y0A9346.png", "2Y0A9419.png",
            "2Y0A9427.png", "2Y0A9433.png", "2Y0A9689.jpg", "Adilova Arofat Faxriddin qizi.jpg",
            "Foto.jpg", "Fozилхонова Zоирхон Даврон o'g'ли 0147.png", "Пулатова Юлдуз.png"
        ];
        
        const names = [
            "Алиев Шерзод Бахтиярович", "Каримова Нилуфар Азимовна", "Рахимов Жасур Олимович",
            "Умарова Дилдора Рустамовна", "Носиров Азиз Фарходович", "Исакова Мадина Шухратовна",
            "Холиков Бахтиёр Мухаммадович", "Турсунова Нигора Анваровна", "Абдуллаев Отабек Камилович",
            "Нурматова Севара Улугбековна", "Мирзаев Фаррух Собирович", "Жуманиязова Гульшан Рахматовна",
            "Хашимов Санжар Тохирович", "Файзуллаева Малика Нуриддиновна", "Самадов Жавлон Икромович",
            "Кодирова Шахноза Абдувахобовна", "Эргашев Достон Мухтарович", "Ибрагимова Дилноза Шавкатовна",
            "Султанов Джахонгир Бахромович", "Хамидова Наргиза Элмуродовна", "Расулов Акмал Садикович",
            "Юсупова Нодира Хакимовна"
        ];
        
        const timeOptions = [
            "15 мин. назад", "30 мин. назад", "45 мин. назад", "1 час назад", "1.5 часа назад", 
            "2 часа назад", "2.5 часа назад", "3 часа назад", "4 часа назад", "5 часов назад"
        ];
        
        // Генерируем новые данные
        function generateRandomOperators() {
            const operators = [];
            const usedAvatars = [];
            const usedNames = [];
            const operatorCount = Math.floor(Math.random() * 6) + 15;
            
            for (let i = 0; i < operatorCount; i++) {
                let avatar;
                if (usedAvatars.length < avatars.length) {
                    do {
                        avatar = avatars[Math.floor(Math.random() * avatars.length)];
                    } while (usedAvatars.includes(avatar));
                    usedAvatars.push(avatar);
                } else {
                    avatar = avatars[Math.floor(Math.random() * avatars.length)];
                }
                
                let name;
                if (usedNames.length < names.length) {
                    do {
                        name = names[Math.floor(Math.random() * names.length)];
                    } while (usedNames.includes(name));
                    usedNames.push(name);
                } else {
                    name = names[Math.floor(Math.random() * names.length)];
                }
                
                const employeeNumber = String(Math.floor(Math.random() * 9000) + 1000);
                const errors = Math.floor(Math.random() * 20); // Необученные ошибки
                const success = Math.floor(Math.random() * 50) + 10; // Успешные обращения
                const trainedErrors = Math.floor(Math.random() * 10); // Обученные ошибки
                const totalErrors = errors + trainedErrors; // Общее количество ошибок (необученные + обученные)
                const status = errors > 10 ? "error" : "success";
                
                // Генерируем дату последнего обучения для обученных операторов
                let lastTrainingDate = null;
                if (errors <= 10 && Math.random() < 0.7) { // 70% обученных операторов имеют дату обучения
                    const daysAgo = Math.floor(Math.random() * 30) + 1; // от 1 до 30 дней назад
                    lastTrainingDate = new Date(Date.now() - daysAgo * 24 * 60 * 60 * 1000);
                }
                
                operators.push({
                    id: i + 1,
                    name: `${name} (${employeeNumber})`,
                    avatar: `assets/Аватар/${avatar}`,
                    errors: errors, // Необученные ошибки
                    success: success, // Успешные обращения  
                    calendar: totalErrors, // Общее количество ошибок (используется поле calendar для обратной совместимости)
                    time: timeOptions[Math.floor(Math.random() * timeOptions.length)],
                    status: status,
                    lastTrainingDate: lastTrainingDate
                });
            }
            
            return operators;
        }
        
        const newOperatorsData = generateRandomOperators();
        window.currentOperatorsData = newOperatorsData;
        
        // Применяем сортировку по умолчанию при обновлении
        const sortedOperators = applyOperatorFilter(newOperatorsData, 'all');
        
        renderOperatorsList(sortedOperators);
        setupOperatorsSearch(newOperatorsData);
        setupOperatorsFilters(newOperatorsData);
    }
    
    // Настройка кнопки обновления
    function setupRefreshButton() {
        const refreshBtn = document.getElementById('refresh-operators-btn');
        if (!refreshBtn) return;
        
        refreshBtn.addEventListener('click', function() {
            // Добавляем анимацию загрузки
            this.classList.add('loading');
            
            // Имитируем небольшую задержку для плавности
            setTimeout(() => {
                refreshOperatorsList();
                this.classList.remove('loading');
                
                // Сбрасываем поиск и фильтры
                const searchInput = document.getElementById('operators-search-input');
                if (searchInput) {
                    searchInput.value = '';
                }
                
                const allFilter = document.querySelector('input[name="operator-filter"][value="all"]');
                if (allFilter) {
                    allFilter.checked = true;
                }
                
                console.log('Список операторов обновлён');
            }, 500);
        });
    }
    
    // Рендеринг списка операторов
    function renderOperatorsList(operators) {
        const container = document.querySelector('.operators-list-container');
        if (!container) return;
        
        container.innerHTML = operators.map(operator => `
            <div class="operator-item" data-operator-id="${operator.id}">
                <img src="${operator.avatar}" 
                     alt="${operator.name}" 
                     class="operator-avatar"
                     onerror="this.src='assets/Аватар/Foto.jpg'; this.onerror=null;">
                <div class="operator-info">
                    <div class="operator-name">${operator.name}</div>
                    <div class="operator-meta">
                        <div class="meta-badge error" title="Необученные ошибки">
                            <span class="material-icons" style="font-size: 12px;">error</span>
                            ${operator.errors}
                        </div>
                        <div class="meta-badge success" title="Успешные обращения">
                            <span class="material-icons" style="font-size: 12px;">check_circle</span>
                            ${operator.success}
                        </div>
                        <!-- Общее количество ошибок (обученных и необученных) -->
                        <div class="meta-badge calendar" title="Общее количество ошибок">
                            <span class="material-icons" style="font-size: 12px;">assignment</span>
                            ${operator.calendar}
                        </div>
                        <div class="meta-time">${operator.time}</div>
                    </div>
                </div>
            </div>
        `).join('');
        
        // Добавляем обработчики клика для выбора оператора
        container.querySelectorAll('.operator-item').forEach(item => {
            item.addEventListener('click', function() {
                // Убираем выделение с других элементов
                container.querySelectorAll('.operator-item').forEach(el => el.classList.remove('selected'));
                // Добавляем выделение к текущему элементу
                this.classList.add('selected');
                
                const operatorId = this.getAttribute('data-operator-id');
                console.log('Выбран оператор с ID:', operatorId);
                
                // Обновляем информацию в окне "Подробная информация ошибок"
                updateOperatorDetails(operatorId);
            });
        });
    }
    
    // Функция генерации ошибок для конкретного оператора
    function generateOperatorErrors(operatorId, operatorName) {
        const errorTypes = [
            "Предупреждение об ожидании на линии: Не сообщил о том за ожидание на линии используется стандартную фразу «Спасибо за ожидание»",
            "Оформление и обработка заявок: Не указал куда ранее обращался заявитель",
            "Качество обслуживания: Недостаточно вежливое общение с клиентом",
            "Техническая поддержка: Не предоставил полную информацию по услуге",
            "Документооборот: Неправильно заполнил форму заявки",
            "Соблюдение регламента: Превышение времени обслуживания клиента",
            "Идентификация клиента: Не запросил дополнительные данные для верификации",
            "Консультирование: Предоставил неактуальную информацию об услугах"
        ];
        
        const services = ["1213_TV", "1000_ru", "1242_mob", "1093_int", "1170_cab"];
        const lkOptions = ["True", "False"];
        
        const errors = [];
        const errorCount = Math.floor(Math.random() * 8) + 3; // 3-10 ошибок
        
        for (let i = 0; i < errorCount; i++) {
            const errorType = errorTypes[Math.floor(Math.random() * errorTypes.length)];
            const service = services[Math.floor(Math.random() * services.length)];
            const lk = lkOptions[Math.floor(Math.random() * lkOptions.length)];
            
            // Генерируем случайную дату и время в пределах последних 30 дней
            const now = new Date();
            const pastDate = new Date(now.getTime() - (Math.random() * 30 * 24 * 60 * 60 * 1000));
            const dateStr = pastDate.toLocaleDateString('ru-RU');
            const timeStr = pastDate.toLocaleTimeString('ru-RU', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            // Генерируем уникальный код ошибки
            const code = `${Math.floor(Math.random() * 90000) + 10000}${String.fromCharCode(65 + Math.floor(Math.random() * 26))}`;
            
            // Случайно определяем, обучен ли оператор по этой ошибке
            const isTrained = Math.random() < 0.3; // 30% шанс что уже обучен
            
            const error = {
                id: i + 1,
                code: code,
                operatorId: operatorId,
                description: errorType,
                date: dateStr,
                time: timeStr,
                service: service,
                lk: lk,
                isTrained: isTrained,
                trainingComments: []
            };
            
            // Если ошибка уже обучена, добавляем комментарий
            if (isTrained) {
                const trainingDate = new Date(pastDate.getTime() + (Math.random() * 7 * 24 * 60 * 60 * 1000));
                const trainingDateStr = trainingDate.toLocaleDateString('ru-RU');
                const trainingTimeStr = trainingDate.toLocaleTimeString('ru-RU', { 
                    hour: '2-digit', 
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                const comments = [
                    "Тушунтириш берилди.",
                    "Операторга мазкур хато борасида тушунтириш берилди.",
                    "Қайтаданланмаслиги учун огохлантирилди.",
                    "Хизмат кўрсатиш сифатини яхшилаш бўйича кўрсатма берилди.",
                    "Регламентга риоя қилиш зарурлиги тушунтирилди."
                ];
                
                const comment = comments[Math.floor(Math.random() * comments.length)];
                
                error.trainingComments.push({
                    id: 1,
                    date: `${trainingDateStr} ${trainingTimeStr}`,
                    text: comment,
                    isOriginal: true
                });
                
                // 20% шанс что комментарий был отредактирован
                if (Math.random() < 0.2) {
                    const editDate = new Date(trainingDate.getTime() + (Math.random() * 3 * 24 * 60 * 60 * 1000));
                    const editDateStr = editDate.toLocaleDateString('ru-RU');
                    const editTimeStr = editDate.toLocaleTimeString('ru-RU', { 
                        hour: '2-digit', 
                        minute: '2-digit',
                        second: '2-digit'
                    });
                    
                    const editComments = [
                        "Масала хал булди",
                        "Қўшимча тушунтириш берилди",
                        "Амалда қўлланилди",
                        "Назорат остида сақланди",
                        "Сифат яхшиланди"
                    ];
                    
                    const editComment = editComments[Math.floor(Math.random() * editComments.length)];
                    
                    error.trainingComments.push({
                        id: 2,
                        date: `${editDateStr} ${editTimeStr}`,
                        text: editComment,
                        isOriginal: false
                    });
                }
            }
            
            errors.push(error);
        }
        
        return errors;
    }
    
    // Полная функция для обновления информации в окне "Подробная информация ошибок"
    function updateOperatorDetails(operatorId) {
        const operator = window.currentOperatorsData.find(op => op.id === Number(operatorId));
        if (!operator) return;
        
        // Показываем информацию о выбранном операторе
        const selectedOperatorInfo = document.getElementById('selected-operator-info');
        const noOperatorSelected = document.getElementById('no-operator-selected');
        const operatorNameIndicator = document.getElementById('operator-name-indicator');
        
        if (selectedOperatorInfo && noOperatorSelected && operatorNameIndicator) {
            selectedOperatorInfo.style.display = 'block';
            noOperatorSelected.style.display = 'none';
            operatorNameIndicator.textContent = `- ${operator.name}`;
        }
        
        // Обновляем аватар и имя оператора
        const avatarImg = document.getElementById('operator-detail-avatar');
        const nameDiv = document.getElementById('operator-detail-name');
        if (avatarImg && nameDiv) {
            avatarImg.src = operator.avatar;
            avatarImg.onerror = () => {
                avatarImg.src = 'assets/Аватар/Foto.jpg';
                avatarImg.onerror = null;
            };
            nameDiv.textContent = operator.name;
        }
        
        // Обновляем статистику
        const errorsSpan = document.getElementById('operator-detail-errors');
        const successSpan = document.getElementById('operator-detail-success');
        if (errorsSpan && successSpan) {
            errorsSpan.textContent = operator.errors;
            successSpan.textContent = operator.success;
        }
        
        // Генерируем и отображаем ошибки оператора
        const operatorErrors = generateOperatorErrors(operatorId, operator.name);
        window.currentOperatorErrors = operatorErrors; // Сохраняем глобально
        
        // Загружаем сохраненные аппеляции
        if (window.appealModal && window.appealModal.loadAppealData) {
            window.appealModal.loadAppealData();
        }
        
        renderOperatorErrors(operatorErrors);
        
        // Инициализируем слайдер даты и времени обучения
        setTimeout(() => {
            if (typeof initTrainingDateToggle === 'function') {
                initTrainingDateToggle();
            }
        }, 100);
        
        console.log(`Загружены детали для оператора: ${operator.name}`);
    }
    
    // Функция для рендеринга списка ошибок оператора
    function renderOperatorErrors(errors) {
        const container = document.getElementById('operator-errors-list');
        if (!container) return;
        
        container.innerHTML = errors.map(error => `
            <div class="error-item ${error.isTrained ? 'trained' : ''}" data-error-id="${error.id}">
                <div class="error-header">
                    <div class="error-info">
                        <div class="error-code">${error.code}</div>
                        <div class="error-details">
                            <div class="error-detail-item">
                                <span class="material-icons">schedule</span>
                                <span>Дата/время: ${error.date} ${error.time}</span>
                            </div>
                            <div class="error-detail-item">
                                <span class="material-icons">build</span>
                                <span>Услуга: ${error.service}</span>
                            </div>
                            <div class="error-detail-item">
                                <span class="material-icons">account_circle</span>
                                <span>ЛК: ${error.lk}</span>
                            </div>
                        </div>
                        <div class="error-description">${error.description}</div>
                    </div>
                    <div class="actions-container">
                        ${!error.isTrained ? `
                            <button class="train-error-btn" onclick="showTrainingForm(${error.id})">
                                <span class="material-icons">school</span>
                                Обучить
                            </button>
                        ` : ''}
                        <button class="appeal-error-btn" onclick="showAppealForm(${error.id})">
                            <span class="material-icons">gavel</span>
                            Аппеляция
                        </button>
                    </div>
                </div>
                
                ${error.trainingComments.length > 0 ? `
                    <div class="training-comments">
                        ${error.trainingComments.map((comment, index) => `
                            <div class="training-comment ${comment.isOriginal ? 'original' : 'edited'}">
                                <div class="comment-date">
                                    ${comment.isOriginal ? 'Дата обучения:' : 'Отредактировано:'} ${comment.date}
                                </div>
                                <div class="comment-text">${comment.text}</div>
                                ${comment.files && comment.files.length > 0 ? `
                                    <div class="comment-files">
                                        <div class="comment-files-title">
                                            <span class="material-icons">attach_file</span>
                                            Прикрепленные файлы (${comment.files.length}):
                                        </div>
                                        ${comment.files.map(file => `
                                            <div class="comment-file-item">
                                                <span class="material-icons">${this.getFileIcon ? this.getFileIcon(file.type) : 'insert_drive_file'}</span>
                                                <span class="comment-file-name">${file.name}</span>
                                                <span class="comment-file-size">(${this.formatFileSize ? this.formatFileSize(file.size) : file.size + ' Б'})</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                                ${index === 0 && error.trainingComments.length > 1 ? `
                                    <div class="comment-arrow">
                                        <span class="material-icons">arrow_forward</span>
                                    </div>
                                ` : ''}
                            </div>
                        `).join('')}
                        <button class="train-error-btn" onclick="editTrainingComment(${error.id})">
                            <span class="material-icons">edit</span>
                            Редактировать
                        </button>
                    </div>
                ` : ''}
                
                <div class="add-comment-form" id="comment-form-${error.id}">
                    <textarea class="comment-input" id="comment-input-${error.id}" 
                              placeholder="Введите комментарий обучения..."></textarea>
                    <div class="comment-form-actions">
                        <button class="comment-btn comment-attach-file-btn">
                            <span class="material-icons">attach_file</span>
                            Прикрепить файл
                        </button>
                        <button class="comment-btn comment-btn-save" onclick="saveTrainingComment(${error.id})">
                            <span class="material-icons">check</span>
                            Сохранить
                        </button>
                        <button class="comment-btn comment-btn-cancel" onclick="cancelTrainingComment(${error.id})">
                            <span class="material-icons">close</span>
                            Отменить
                        </button>
                    </div>
                </div>
                
                ${error.appeals && error.appeals.length > 0 ? `
                    <div class="appeals-list">
                        <h4>Аппеляции:</h4>
                        ${error.appeals.map(appeal => `
                            <div class="appeal-item">
                                <div class="appeal-date">
                                    <span class="material-icons">schedule</span>
                                    Отправлено: ${appeal.date}
                                </div>
                                <div class="appeal-text">${appeal.text}</div>
                                ${appeal.files && appeal.files.length > 0 ? `
                                    <div class="appeal-files">
                                        <div class="appeal-files-title">
                                            <span class="material-icons">attach_file</span>
                                            Прикрепленные файлы (${appeal.files.length}):
                                        </div>
                                        ${appeal.files.map(file => `
                                            <div class="appeal-file-item">
                                                <span class="material-icons">${this.getFileIcon ? this.getFileIcon(file.type) : 'insert_drive_file'}</span>
                                                <span class="appeal-file-name">${file.name}</span>
                                                <span class="appeal-file-size">(${this.formatFileSize ? this.formatFileSize(file.size) : file.size + ' Б'})</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                                <div class="appeal-status ${appeal.status}">
                                    <span class="material-icons">
                                        ${appeal.status === 'pending' ? 'hourglass_empty' : 
                                          appeal.status === 'approved' ? 'check_circle' : 'cancel'}
                                    </span>
                                    ${appeal.status === 'pending' ? 'На рассмотрении' : 
                                      appeal.status === 'approved' ? 'Одобрено' : 'Отклонено'}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            </div>
        `).join('');
    }
    
    // Функция для показа формы обучения
    function showTrainingForm(errorId) {
        const form = document.getElementById(`comment-form-${errorId}`);
        if (form) {
            form.classList.add('show');
            const input = document.getElementById(`comment-input-${errorId}`);
            if (input) {
                input.focus();
            }
        }
    }
    
    // Функция для сохранения комментария обучения
    function saveTrainingComment(errorId) {
        const input = document.getElementById(`comment-input-${errorId}`);
        const form = document.getElementById(`comment-form-${errorId}`);
        
        if (!input || !form) return;
        
        const commentText = input.value.trim();
        if (!commentText) {
            alert('Пожалуйста, введите комментарий');
            return;
        }
        
        // Получаем прикрепленные файлы
        const attachedFiles = window.getCommentAttachedFiles ? window.getCommentAttachedFiles(form) : [];
        
        // Находим ошибку в данных
        const error = window.currentOperatorErrors.find(err => err.id === errorId);
        if (!error) return;
        
        // Создаем новый комментарий
        const now = new Date();
        const dateStr = now.toLocaleDateString('ru-RU');
        const timeStr = now.toLocaleTimeString('ru-RU', { 
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit'
        });
        
        const newComment = {
            id: error.trainingComments.length + 1,
            date: `${dateStr} ${timeStr}`,
            text: commentText,
            isOriginal: error.trainingComments.length === 0,
            files: attachedFiles.map(fileData => ({
                name: fileData.name,
                size: fileData.size,
                type: fileData.type,
                id: fileData.id
            }))
        };
        
        // Добавляем комментарий и помечаем ошибку как обученную
        error.trainingComments.push(newComment);
        error.isTrained = true;
        
        // Очищаем форму и прикрепленные файлы
        input.value = '';
        if (window.clearCommentAttachedFiles) {
            window.clearCommentAttachedFiles(form);
        }
        
        // Перерендериваем список ошибок
        renderOperatorErrors(window.currentOperatorErrors);
        
        // Показываем уведомление
        const fileCountText = attachedFiles.length > 0 ? ` с ${attachedFiles.length} файлом(ами)` : '';
        console.log(`Добавлен комментарий${fileCountText} для ошибки ${errorId}: ${commentText}`);
    }
    
    // Функция для отмены добавления комментария
    function cancelTrainingComment(errorId) {
        const form = document.getElementById(`comment-form-${errorId}`);
        const input = document.getElementById(`comment-input-${errorId}`);
        
        if (form && input) {
            form.classList.remove('show');
            input.value = '';
            
            // Очищаем прикрепленные файлы
            if (window.clearCommentAttachedFiles) {
                window.clearCommentAttachedFiles(form);
            }
        }
    }
    
    // Функция для редактирования комментария обучения
    function editTrainingComment(errorId) {
        const error = window.currentOperatorErrors.find(err => err.id === errorId);
        if (!error || error.trainingComments.length === 0) return;
        
        const lastComment = error.trainingComments[error.trainingComments.length - 1];
        const newCommentText = prompt('Редактировать комментарий:', lastComment.text);
        
        if (newCommentText && newCommentText.trim() !== lastComment.text) {
            // Создаем новый "отредактированный" комментарий
            const now = new Date();
            const dateStr = now.toLocaleDateString('ru-RU');
            const timeStr = now.toLocaleTimeString('ru-RU', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            
            const editedComment = {
                id: error.trainingComments.length + 1,
                date: `${dateStr} ${timeStr}`,
                text: newCommentText.trim(),
                isOriginal: false
            };
            
            error.trainingComments.push(editedComment);
            
            // Перерендериваем список ошибок
            renderOperatorErrors(window.currentOperatorErrors);
        }
    }
    
    // Настройка поиска операторов
    function setupOperatorsSearch(allOperators) {
        const searchInput = document.getElementById('operators-search-input');
        if (!searchInput) return;
        
        searchInput.addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase().trim();
            
            let filteredOperators = allOperators;
            
            // Применяем поиск
            if (searchTerm) {
                filteredOperators = filteredOperators.filter(operator => 
                    operator.name.toLowerCase().includes(searchTerm)
                );
            }
            
            // Применяем текущий фильтр
            const activeFilter = document.querySelector('input[name="operator-filter"]:checked');
            if (activeFilter) {
                filteredOperators = applyOperatorFilter(filteredOperators, activeFilter.value);
            }
            
            renderOperatorsList(filteredOperators);
        });
    }
    
    // Настройка фильтров операторов
    function setupOperatorsFilters(allOperators) {
        const filterRadios = document.querySelectorAll('input[name="operator-filter"]');
        
        filterRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.checked) {
                    let filteredOperators = allOperators;
                    
                    // Применяем поиск если есть
                    const searchInput = document.getElementById('operators-search-input');
                    if (searchInput && searchInput.value.trim()) {
                        const searchTerm = searchInput.value.toLowerCase().trim();
                        filteredOperators = filteredOperators.filter(operator => 
                            operator.name.toLowerCase().includes(searchTerm)
                        );
                    }
                    
                    // Применяем фильтр
                    filteredOperators = applyOperatorFilter(filteredOperators, this.value);
                    
                    renderOperatorsList(filteredOperators);
                }
            });
        });
    }
    
    // Применение фильтра к операторам
    function applyOperatorFilter(operators, filterValue) {
        let filteredOperators = [...operators]; // Создаем копию массива
        
        switch (filterValue) {
            case 'all':
                // Режим "Все": показываем всех операторов, сортируем по убыванию количества ошибок
                filteredOperators.sort((a, b) => b.errors - a.errors);
                break;
                
            case 'untrained':
                // Режим "Необученные": только операторы с ошибками > 10, сортируем по убыванию ошибок
                filteredOperators = filteredOperators.filter(op => op.errors > 10);
                filteredOperators.sort((a, b) => b.errors - a.errors);
                break;
                
            case 'training-date':
                // Режим "Дата обучения": только обученные операторы, сортируем по дате обучения (старые сверху)
                filteredOperators = filteredOperators.filter(op => op.lastTrainingDate !== null);
                filteredOperators.sort((a, b) => {
                    // Сортируем по дате обучения: более старые даты сверху
                    return a.lastTrainingDate - b.lastTrainingDate;
                });
                break;
                
            default:
                // По умолчанию сортируем по убыванию ошибок
                filteredOperators.sort((a, b) => b.errors - a.errors);
                break;
        }
        
        return filteredOperators;
    }
    
    // Функция для показа уведомления
    function showNotification(message, type = 'info') {
        // Создаем элемент уведомления
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
            <span class="material-icons">${type === 'info' ? 'info' : 'warning'}</span>
            <span>${message}</span>
        `;
        
        // Добавляем стили для уведомления
        notification.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: ${type === 'info' ? '#e3f2fd' : '#fff3e0'};
            color: ${type === 'info' ? '#1976d2' : '#f57c00'};
            border: 1px solid ${type === 'info' ? '#bbdefb' : '#ffcc02'};
            border-radius: 8px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            animation: slideInRight 0.3s ease;
            max-width: 300px;
            font-size: 14px;
        `;
        
        // Добавляем CSS анимацию если её нет
        if (!document.querySelector('#notification-styles')) {
            const style = document.createElement('style');
            style.id = 'notification-styles';
            style.textContent = `
                @keyframes slideInRight {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                @keyframes slideOutRight {
                    from {
                        transform: translateX(0);
                        opacity: 1;
                    }
                    to {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        document.body.appendChild(notification);
        
        // Автоматически убираем уведомление через 3 секунды
        setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.3s ease';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    
    // Делаем функции глобальными для вызова из HTML
    window.showTrainingForm = showTrainingForm;
    window.saveTrainingComment = saveTrainingComment;
    window.cancelTrainingComment = cancelTrainingComment;
    window.editTrainingComment = editTrainingComment;
    
    // Функция инициализации окон 
    function initializeWindows() {
        const windows = document.querySelectorAll('.training-window');
        windows.forEach(window => {
            makeWindowDraggable(window);
            makeWindowResizable(window);
            addWindowControls(window);
        });
        
        // Инициализируем кнопки развертывания в отключенном состоянии
        document.querySelectorAll('.maximize-btn').forEach(btn => {
            btn.classList.add('disabled');
            btn.style.cursor = 'not-allowed';
            btn.title = 'Развертывание доступно только в режиме редактирования';
        });
        
        // Инициализируем кнопки свертывания (они всегда активны)
        document.querySelectorAll('.minimize-btn').forEach(btn => {
            btn.classList.remove('disabled');
            btn.style.cursor = 'pointer';
            btn.title = 'Свернуть/развернуть окно';
        });
    }

    // Функция для создания draggable окна
    function makeWindowDraggable(windowElement) {
        const header = windowElement.querySelector('.window-header');
        let isDragging = false;
        let currentX = 0;
        let currentY = 0;
        let initialX = 0;
        let initialY = 0;
        let xOffset = 0;
        let yOffset = 0;
        
        if (!header) return;
        
        header.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
        
        function dragStart(e) {
            // Проверяем, что режим редактирования активен
            if (!editMode) {
                return;
            }
            
            if (e.target.closest('.window-controls')) return;
            
            initialX = e.clientX - xOffset;
            initialY = e.clientY - yOffset;
            
            if (e.target === header || header.contains(e.target)) {
                isDragging = true;
                windowElement.classList.add('dragging');
            }
        }
        
        function drag(e) {
            // Проверяем, что режим редактирования активен и происходит перетаскивание
            if (isDragging && editMode) {
                e.preventDefault();
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                
                xOffset = currentX;
                yOffset = currentY;
                
                // Ограничиваем перемещение в пределах training-layout
                const trainingLayout = document.querySelector('.training-layout');
                
                if (trainingLayout) {
                    const containerRect = trainingLayout.getBoundingClientRect();
                    const windowRect = windowElement.getBoundingClientRect();
                    
                    // Рассчитываем максимальные позиции с учетом размеров окна
                    const maxX = containerRect.width - windowRect.width - 20; // 20px отступ справа
                    const maxY = containerRect.height - windowRect.height - 20; // 20px отступ снизу
                    
                    // Ограничиваем позицию
                    currentX = Math.max(20, Math.min(currentX, maxX)); // минимум 20px слева
                    currentY = Math.max(20, Math.min(currentY, maxY)); // минимум 20px сверху
                    
                    // Дополнительная проверка: окно не должно выходить за правую и нижнюю границы
                    const windowWidth = parseInt(windowElement.style.width) || windowRect.width;
                    const windowHeight = parseInt(windowElement.style.height) || windowRect.height;
                    
                    if (currentX + windowWidth > containerRect.width - 15) {
                        currentX = containerRect.width - windowWidth - 15;
                    }
                    
                    if (currentY + windowHeight > containerRect.height - 15) {
                        currentY = containerRect.height - windowHeight - 15;
                    }
                }
                
                windowElement.style.left = currentX + 'px';
                windowElement.style.top = currentY + 'px';
            }
        }
        
        function dragEnd() {
            initialX = currentX;
            initialY = currentY;
            isDragging = false;
            windowElement.classList.remove('dragging');
        }
    }

    // Функция для добавления контролов окна
    function addWindowControls(windowElement) {
        const minimizeBtn = windowElement.querySelector('.minimize-btn');
        const maximizeBtn = windowElement.querySelector('.maximize-btn');
        const closeBtn = windowElement.querySelector('.close-btn');
        
        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', () => {
                // Минимизация доступна всегда
                const isMinimized = windowElement.classList.contains('minimized');
                const icon = minimizeBtn.querySelector('.material-icons');
                
                if (isMinimized) {
                    // Разворачиваем окно
                    windowElement.classList.remove('minimized');
                    icon.textContent = 'remove';
                    minimizeBtn.title = 'Свернуть окно';
                    
                    // Если окно было максимизировано до минимизации, возвращаем это состояние
                    const wasMaximized = windowElement.getAttribute('data-was-maximized') === 'true';
                    if (wasMaximized) {
                        windowElement.classList.add('maximized');
                        windowElement.removeAttribute('data-was-maximized');
                    }
                } else {
                    // Сворачиваем окно
                    // Если окно было максимизировано, запоминаем это
                    if (windowElement.classList.contains('maximized')) {
                        windowElement.setAttribute('data-was-maximized', 'true');
                        windowElement.classList.remove('maximized');
                    }
                    windowElement.classList.add('minimized');
                    icon.textContent = 'expand_more';
                    minimizeBtn.title = 'Развернуть окно';
                }
                
                // Сохраняем состояние окна
                WindowStateManager.saveWindowState(windowElement);
            });
        }
        
        if (maximizeBtn) {
            maximizeBtn.addEventListener('click', () => {
                // Проверяем, включен ли режим редактирования
                if (!editMode) {
                    return; // Блокируем развертывание в обычном режиме
                }
                
                const isMaximized = windowElement.classList.contains('maximized');
                
                if (!isMaximized) {
                    // Сохраняем текущие размеры и позицию
                    windowElement.setAttribute('data-original-width', windowElement.style.width || '320px');
                    windowElement.setAttribute('data-original-height', windowElement.style.height || '220px');
                    windowElement.setAttribute('data-original-left', windowElement.style.left || '20px');
                    windowElement.setAttribute('data-original-top', windowElement.style.top || '20px');
                    
                    // Максимизируем окно
                    windowElement.classList.add('maximized');
                } else {
                    // Восстанавливаем оригинальные размеры
                    const originalWidth = windowElement.getAttribute('data-original-width');
                    const originalHeight = windowElement.getAttribute('data-original-height');
                    const originalLeft = windowElement.getAttribute('data-original-left');
                    const originalTop = windowElement.getAttribute('data-original-top');
                    
                    if (originalWidth) windowElement.style.width = originalWidth;
                    if (originalHeight) windowElement.style.height = originalHeight;
                    if (originalLeft) windowElement.style.left = originalLeft;
                    if (originalTop) windowElement.style.top = originalTop;
                    
                    windowElement.classList.remove('maximized');
                }
                
                // Сохраняем состояние окна
                WindowStateManager.saveWindowState(windowElement);
            });
        }
        
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                windowElement.style.display = 'none';
                
                // Обновляем состояние чекбокса в выпадающем списке
                const windowId = windowElement.id;
                let dataWindow = '';
                
                if (windowId === 'operators-errors-window') {
                    dataWindow = 'operators-list';
                } else if (windowId === 'operator-details-window') {
                    dataWindow = 'operator-details';
                } else if (windowId === 'analytics-dashboard-window') {
                    dataWindow = 'analytics-dashboard';
                }
                
                if (dataWindow) {
                    const checkbox = document.querySelector(`input[data-window="${dataWindow}"]`);
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                }
                
                // Сохраняем состояние окна
                WindowStateManager.saveWindowState(windowElement);
                
                // Сохраняем состояние всех окон
                WindowStateManager.saveAllWindowStates();
                
                // Проверяем нужно ли показать заглушку
                checkPlaceholderVisibility();
            });
        }
    }

    function makeWindowResizable(windowElement) {
        const resizeHandle = windowElement.querySelector('.resize-handle');
        if (!resizeHandle) return;
        
        let isResizing = false;
        let startX, startY, startWidth, startHeight;
        
        resizeHandle.addEventListener('mousedown', initResize);
        
        function initResize(e) {
            isResizing = true;
            startX = e.clientX;
            startY = e.clientY;
            startWidth = parseInt(document.defaultView.getComputedStyle(windowElement).width, 10);
            startHeight = parseInt(document.defaultView.getComputedStyle(windowElement).height, 10);
            
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
            
            e.preventDefault();
            e.stopPropagation();
        }
        
        function doResize(e) {
            if (!isResizing) return;
            
            const newWidth = startWidth + e.clientX - startX;
            const newHeight = startHeight + e.clientY - startY;
            
            // Получаем размеры основного контейнера training-layout
            const trainingLayout = document.querySelector('.training-layout');
            let maxWidth = 1200;
            let maxHeight = 800;
            
            if (trainingLayout) {
                const layoutRect = trainingLayout.getBoundingClientRect();
                const windowRect = windowElement.getBoundingClientRect();
                
                // Вычисляем максимальные размеры с учетом позиции окна
                const windowLeftInContainer = windowRect.left - layoutRect.left;
                const windowTopInContainer = windowRect.top - layoutRect.top;
                
                // Максимальные размеры = размер контейнера - позиция окна - отступы
                maxWidth = Math.max(220, layoutRect.width - windowLeftInContainer - 20);
                maxHeight = Math.max(140, layoutRect.height - windowTopInContainer - 20);
                
                // Дополнительная проверка: окно не должно выходить за пределы
                const potentialRight = windowLeftInContainer + newWidth;
                const potentialBottom = windowTopInContainer + newHeight;
                
                if (potentialRight > layoutRect.width - 20) {
                    maxWidth = layoutRect.width - windowLeftInContainer - 20;
                }
                
                if (potentialBottom > layoutRect.height - 20) {
                    maxHeight = layoutRect.height - windowTopInContainer - 20;
                }
            }
            
            // Ограничения по размеру
            const minWidth = 220;
            const minHeight = 140;
            
            const constrainedWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
            const constrainedHeight = Math.max(minHeight, Math.min(newHeight, maxHeight));
            
            windowElement.style.width = constrainedWidth + 'px';
            windowElement.style.height = constrainedHeight + 'px';
            
            // После изменения размера проверяем, что окно все еще в пределах контейнера
            setTimeout(() => {
                const updatedWindowRect = windowElement.getBoundingClientRect();
                if (trainingLayout) {
                    const containerRect = trainingLayout.getBoundingClientRect();
                    
                    // Если окно выходит за правую границу
                    if (updatedWindowRect.right > containerRect.right - 15) {
                        const newLeft = containerRect.right - updatedWindowRect.width - 15;
                        windowElement.style.left = Math.max(15, newLeft - containerRect.left) + 'px';
                    }
                    
                    // Если окно выходит за нижнюю границу
                    if (updatedWindowRect.bottom > containerRect.bottom - 15) {
                        const newTop = containerRect.bottom - updatedWindowRect.height - 15;
                        windowElement.style.top = Math.max(15, newTop - containerRect.top) + 'px';
                    }
                }
            }, 0);
        }
        
        function stopResize() {
            isResizing = false;
            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', stopResize);
            
            // Сохраняем состояние окна после изменения размера
            WindowStateManager.saveWindowState(windowElement);
        }
    }
    
    // Система сохранения состояния окон
    const WindowStateManager = {
        storageKey: 'windowStates',
        
        // Сохранение состояния конкретного окна
        saveWindowState: function(windowElement) {
            const windowId = windowElement.id;
            if (!windowId) return;
            
            const state = {
                width: windowElement.style.width || '320px',
                height: windowElement.style.height || '220px',
                left: windowElement.style.left || '20px',
                top: windowElement.style.top || '20px',
                zIndex: windowElement.style.zIndex || 'auto',
                visible: windowElement.style.display !== 'none',
                maximized: windowElement.classList.contains('maximized'),
                minimized: windowElement.classList.contains('minimized'),
                wasMaximized: windowElement.getAttribute('data-was-maximized') === 'true'
            };
            this.saveState(windowId, state);
        },
        
        // Сохранение состояния всех окон
        saveAllWindowStates: function() {
            const windows = document.querySelectorAll('.training-window');
            windows.forEach(window => {
                this.saveWindowState(window);
            });
            
            // Сохраняем состояние чекбоксов
            const checkboxStates = {};
            const checkboxes = document.querySelectorAll('.window-selector-item input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                const windowType = checkbox.getAttribute('data-window');
                if (windowType) {
                    checkboxStates[windowType] = checkbox.checked;
                }
            });
            localStorage.setItem('windowCheckboxStates', JSON.stringify(checkboxStates));
            
            console.log('Состояние всех окон сохранено');
        },
        
        // Сохранение состояния конкретного окна в localStorage
        saveState: function(windowId, state) {
            const savedStates = this.getAllStates();
            savedStates[windowId] = state;
            localStorage.setItem(this.storageKey, JSON.stringify(savedStates));
        },
        
        // Получение всех сохраненных состояний
        getAllStates: function() {
            const saved = localStorage.getItem(this.storageKey);
            return saved ? JSON.parse(saved) : {};
        },
        
        // Получение состояния конкретного окна
        getWindowState: function(windowId) {
            const states = this.getAllStates();
            return states[windowId] || null;
        },
        
        // Очистка всех сохраненных состояний
       
        clearStates: function() {
            localStorage.removeItem(this.storageKey);
            localStorage.removeItem('windowCheckboxStates');
            console.log('Все сохраненные состояния окон очищены');
        },
        
        // Восстановление состояния конкретного окна
        restoreWindowState: function(windowElement) {
            const windowId = windowElement.id;
            if (!windowId) return;
            
            const state = this.getWindowState(windowId);
            if (!state) return;
            
            // Восстанавливаем размеры и позицию
            windowElement.style.width = state.width;
            windowElement.style.height = state.height;
            windowElement.style.left = state.left;
            windowElement.style.top = state.top;
            
            if (state.zIndex !== 'auto') {
                windowElement.style.zIndex = state.zIndex;
            }
            
            // Восстанавливаем состояние максимизации/минимизации
            if (state.maximized) {
                windowElement.classList.add('maximized');
            } else {
                windowElement.classList.remove('maximized');
            }
            
            if (state.minimized) {
                windowElement.classList.add('minimized');
                // Восстанавливаем атрибут was-maximized если он был
                if (state.wasMaximized) {
                    windowElement.setAttribute('data-was-maximized', 'true');
                }
                // Обновляем иконку кнопки минимизации
                const minimizeBtn = windowElement.querySelector('.minimize-btn .material-icons');
                if (minimizeBtn) {
                    minimizeBtn.textContent = 'expand_more';
                    windowElement.querySelector('.minimize-btn').title = 'Развернуть окно';
                }
            } else {
                windowElement.classList.remove('minimized');
                windowElement.removeAttribute('data-was-maximized');
                // Обновляем иконку кнопки минимизации
                const minimizeBtn = windowElement.querySelector('.minimize-btn .material-icons');
                if (minimizeBtn) {
                    minimizeBtn.textContent = 'remove';
                    windowElement.querySelector('.minimize-btn').title = 'Свернуть окно';
                }
            }
            
            // Восстанавливаем видимость
            if (state.visible) {
                windowElement.style.display = 'flex';
                
                // Для окна операторов инициализируем данные
                if (windowId === 'operators-errors-window') {
                    setTimeout(() => {
                        initOperatorsList();
                    }, 100);
                }
            } else {
                windowElement.style.display = 'none';
            }
            
            console.log(`Состояние окна ${windowId} восстановлено`);
        },
        
        // Восстановление состояния всех окон
        restoreAllWindowStates: function() {
            // Восстанавливаем состояние чекбоксов
            const checkboxStates = localStorage.getItem('windowCheckboxStates');
            if ( checkboxStates) {
                try {
                    const states = JSON.parse(checkboxStates);
                    Object.keys(states).forEach(windowType => {
                        const checkbox = document.querySelector(`input[data-window="${windowType}"]`);
                        if (checkbox) {
                            checkbox.checked = states[windowType];
                        }
                    });
                } catch (e) {
                    console.error('Ошибка при восстановлении состояния чекбоксов:', e);
                }
            }
            
            // Восстанавливаем состояние окон
            const windows = document.querySelectorAll('.training-window');
            windows.forEach(window => {
                this.restoreWindowState(window);
            });
            
            console.log('Состояние всех окон восстановлено');
        },
        
        // Настройка автосохранения при изменениях
        setupAutoSave: function() {
            // Сохранение при изменении размера окон
            const resizeObserver = new ResizeObserver(entries => {
                entries.forEach(entry => {
                    const element = entry.target;
                    if (element.classList.contains('training-window')) {
                        setTimeout(() => {
                            this.saveWindowState(element);
                        }, 100);
                    }
                });
            });
            
            // Наблюдаем за всеми окнами
            document.querySelectorAll('.training-window').forEach(window => {
                resizeObserver.observe(window);
            });
            
            // Сохранение при изменении DOM (добавление/удаление окон)
            const mutationObserver = new MutationObserver(mutations => {
                let shouldSave = false;
                mutations.forEach(mutation => {
                    if (mutation.type === 'attributes' && 
                        (mutation.attributeName === 'style' || mutation.attributeName === 'class')) {
                        const element = mutation.target;
                        if (element.classList.contains('training-window')) {
                            shouldSave = true;
                        }
                    }
                });
                
                if (shouldSave) {
                    setTimeout(() => {
                        this.saveAllWindowStates();
                    }, 100);
                }
            });
            
            // Наблюдаем за изменениями в контейнере окон
            const trainingLayout = document.querySelector('.training-layout');
            if (trainingLayout) {
                mutationObserver.observe(trainingLayout, {
                    attributes: true,
                    subtree: true,
                    attributeFilter: ['style', 'class']
                });
            }
            
            console.log('Автосохранение настроено');
        }
    };
    
    // Инициализация состояния окон при загрузке
    WindowStateManager.restoreAllWindowStates();
    
    // Инициализация окон при загрузке
    initializeWindows();
    
    // Восстанавливаем сохраненное состояние окон
    setTimeout(() => {
        WindowStateManager.restoreAllWindowStates();
        // Настраиваем автосохранение
        WindowStateManager.setupAutoSave();
    }, 100);
    
    // Добавляем обработчики для кнопок редактора
    const resetWindowsBtn = document.getElementById('reset-windows-btn');
    if (resetWindowsBtn) {
        resetWindowsBtn.addEventListener('click', async function(e) {
            e.preventDefault();
            
            const confirmed = await showCustomConfirm(
                'Сброс настроек окон',
                'Вы уверены, что хотите сбросить все настройки окон? Это действие нельзя отменить.',
                'Сбросить',
                'Отмена'
            );
            
            if (confirmed) {
                // Очищаем сохраненные состояния
                WindowStateManager.clearStates();
                
                // Сбрасываем все окна к исходному состоянию - все скрыты
                const windows = document.querySelectorAll('.training-window');
                windows.forEach(window => {
                    // Все окна скрываем после сброса
                    window.style.display = 'none';
                    window.style.width = '320px';
                    window.style.height = '220px';
                    window.style.left = '20px';
                    window.style.top = '20px';
                    window.style.zIndex = 'auto';
                    window.classList.remove('maximized', 'minimized');
                });
                
                // Сбрасываем все чекбоксы к неактивному состоянию
                const checkboxes = document.querySelectorAll('.window-selector-item input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                    // Все чекбоксы отключаем после сброса
                    checkbox.checked = false;
                });
                
                // Показываем заглушку (но только после того, как настроили окна)
                setTimeout(() => {
                    checkPlaceholderVisibility();
                }, 200);
                
                showNotification('Настройки окон сброшены. Все окна скрыты.', 'info');
                console.log('Настройки окон сброшены к исходному состоянию - все окна скрыты');
            }
        });
    }
    
    // Функция для создания красивого модального окна подтверждения
    function showCustomConfirm(title, message, confirmText = 'Да', cancelText = 'Отмена') {
        return new Promise((resolve) => {
            // Создаем модальное окно
            const modal = document.createElement('div');
            modal.className = 'custom-modal';
            
            modal.innerHTML = `
                <div class="custom-modal-content">
                    <div class="custom-modal-header">
                        <div class="custom-modal-icon">
                            <span class="material-icons">warning</span>
                        </div>
                        <h3 class="custom-modal-title">${title}</h3>
                    </div>
                    <div class="custom-modal-text">${message}</div>
                    <div class="custom-modal-buttons">
                        <button class="custom-modal-btn custom-modal-btn-cancel" data-action="cancel">
                            ${cancelText}
                        </button>
                        <button class="custom-modal-btn custom-modal-btn-confirm" data-action="confirm">
                            ${confirmText}
                        </button>
                    </div>
                </div>
            `;
            
            // Добавляем модальное окно на страницу
            document.body.appendChild(modal);
            
            // Обработчики событий
            const handleClick = (e) => {
                const action = e.target.getAttribute('data-action');
                if (action === 'confirm') {
                    closeModal(true);
                } else if (action === 'cancel') {
                    closeModal(false);
                }
            };
            
            const handleKeydown = (e) => {
                if (e.key === 'Escape') {
                    closeModal(false);
                } else if (e.key === 'Enter') {
                    closeModal(true);
                }
            };
            
            const closeModal = (result) => {
                // Анимация закрытия
                modal.style.animation = 'modalFadeOut 0.3s ease';
                const content = modal.querySelector('.custom-modal-content');
                content.style.animation = 'modalSlideOut 0.3s ease';
                
                setTimeout(() => {
                    document.body.removeChild(modal);
                    document.removeEventListener('keydown', handleKeydown);
                    resolve(result);
                }, 300);
            };
            
            // Добавляем обработчики
            modal.addEventListener('click', (e) => {
                // Закрываем при клике на фон
                if (e.target === modal) {
                    closeModal(false);
                }
            });
            
            modal.addEventListener('click', handleClick);
            document.addEventListener('keydown', handleKeydown);
            
            // Фокус на кнопке отмены по умолчанию
            setTimeout(() => {
                const cancelBtn = modal.querySelector('[data-action="cancel"]');
                if (cancelBtn) {
                    cancelBtn.focus();
                }
            }, 100);
        });
    }
    
    // Автоматически инициализируем окно операторов если оно отмечено как включенное
    setTimeout(() => {
        const operatorsCheckbox = document.querySelector('input[data-window="operators-list"]');
        const operatorsWindow = document.getElementById('operators-errors-window');
        
        if (operatorsCheckbox && operatorsCheckbox.checked && operatorsWindow) {
            if (operatorsWindow.style.display === 'none') {
                addWindow('operators-list');
            } else if (operatorsWindow.style.display === 'flex' || operatorsWindow.style.display === '') {
                initOperatorsList();
            }
        }
    }, 200);
    const operatorsCheckbox = document.querySelector('input[data-window="operators-list"]');
    if (operatorsCheckbox && operatorsCheckbox.checked) {
        addWindow('operators-list');
    }
    
    // Проверяем видимость заглушки при загрузке
    checkPlaceholderVisibility();
});
        </script>
        
        <!-- Старые рабочие скрипты для совместимости -->
        <script src="script.js"></script>
        
        <script>
        // Простая инициализация без модулей
        document.addEventListener('DOMContentLoaded', function() {
            console.log('✅ Приложение загружается...');
            
            try {
                // Инициализируем основные функции из script.js
                if (typeof initOperatorsList === 'function') {
                    initOperatorsList();
                }
                
                console.log('✅ Приложение успешно загружено');
                
            } catch (error) {
                console.error('❌ Ошибка загрузки:', error);
            }
        });
        </script>
        <script src="js/training-date-toggle.js"></script>
        <script src="js/slider-tooltip.js"></script>
        <script src="js/appeal-modal.js"></script>
    </body>
</html>
